# 
# Simulator called my master class, simulates simple user inputs on textboxes and buttons
# 

import pyautogui as pg
import getopt as options
import sys
import json
import time


# ---------------------------------------------------------------------------------------------------------------
# Configurations
# ---------------------------------------------------------------------------------------------------------------
pg.FAILSAFE = False
pg.PAUSE = .05

TEXT_INTERVAL = .075
RESULT_PATH = "../../temp result/temp.json"
TEST_CASE_PATH = "../../temp result/testcases/testcases.json"


# ---------------------------------------------------------------------------------------------------------------
# Default fallback data
# ---------------------------------------------------------------------------------------------------------------
FULL_NAME = ["full name", "fullname", "name", "your name"]
FIRST_NAME = ["first name", "first", "firstname", "your first name", "your firstname"]
LAST_NAME = ["last name", "lastname", "surname", "your last name", "your lastname"]
PHONE = ["phone", "telephone", "mobile", "number", "phone number", "tel", "mobile number", "cell phone", "your phone number"]
EMAIL = ["email", "e-mail", "e mail", "gmail", "g-mail", "g mail", "mail", "email address", "username", "your email address"]
WEBSITE = ["website", "web", "web address", "your website", "your web address"]
PASSWORD = ["password", "confirm password", "pass", "re-enter password", "enter password", "enter password again"]

text_input = {
    "name": "default Team 17 Duy Tan",
    "email": "default team17@team17.duytan.edu",
    "phone": "+9999999999",
    "firstname": "default Team 17",
    "lastname": "default Duy Tan",
    "password": "default123456789Aa",
    "website": "default https://team17.duytan.edu.com/chacocaigi"
}


# ---------------------------------------------------------------------------------------------------------------
# Intermediate functions
# ---------------------------------------------------------------------------------------------------------------

# Get detection results from Main app
def __get_results():
    boxes = []
    with open(RESULT_PATH) as result_file:
        results = json.load(result_file)
        for result in results:
            if result["class_name"] == "tb":
                boxes.append(result)
        result_file.close()
    return boxes

# Get testcases generated by Main app
def __get_test_cases():
    tests = []
    with open(TEST_CASE_PATH) as testcases_file:
        fields = json.load(testcases_file)
        for field in fields:
            __lower(field["associated"])
            test = {
                "field_name": field["field_name"],
                "associated": field["associated"],
                "error": (field["error_forces"] + field["error_rejects"]) + [field["upper"], field["lower"]],
                "valid": field["valid"]
            }
            tests.append(test)
        testcases_file.close()
    print(tests)
    return tests

# Self-explanatory
def __lower(list):
    for item in list:
        item = item.lower()

# This part is very poor in performance, a DLL call might solve it much faster
def __classify(present_text, texts_to_match):
    if len(texts_to_match) <= 0:
        return False
    for text in texts_to_match:
        if text in present_text:
            return True
    return False

# Create a box object
def __create_box(simple_id, key, center_x, center_y, fields):
    error = [""]
    valid = {"Item1": "", "Item2": ""}
    for field in fields:
        if key == field["field_name"]:
            valid = field["valid"]
            error = field["error"]
            break
    return {
        "simple_id": simple_id,
        "key": key,
        "center_x": center_x,
        "center_y": center_y,
        "error": error,
        "valid": valid
    }

# Classify boxes into recognized and unrecognized
def __classify_boxes(boxes, fields, fallback):
    classified_box = []

    for idx, box in enumerate(boxes):
        # boxes with unrecognized texts are fallbacks by default
        if len(box["text"]) <= 0 and fallback:
            classified_box.append(__create_box(idx, "<fallback>", box["center_x"], box["center_y"], fields))
            continue
        # boxes with identified texts are classified into fields
        added = False
        for field in fields:
            if __classify(box["text"], field["associated"]):
                classified_box.append(__create_box(idx, field["field_name"], box["center_x"], box["center_y"], fields))
                added = True
                break
        # unclassified boxes are also fallbacks
        if not added and fallback:
            classified_box.append(__create_box(idx, "<fallback>", box["center_x"], box["center_y"], fields))
    print(classified_box)
    return classified_box

# Simulate error inputs
def __simulate_error(error_box, error, boxes):
    "Simulate error inputs: error for specified field, valid for the rest"
    
    for box in boxes:
        if box["simple_id"] == error_box["simple_id"]:
            __input_text_at(error, box)
        else:
            __input_text_at(box["valid"]["Item2"], box)

# Input text into a textbox
def __input_text_at(text, box):
    pg.click(x = box["center_x"], y = box["center_y"], interval = .1, button = "left", clicks = 3)
    pg.typewrite(text, interval = TEXT_INTERVAL)
    print(text)

# Simulate input on unrecognized fields
def __simulate_unrecognized(boxes):
    for idx, tb in enumerate(boxes):
        pg.click(x = tb["center_x"], y = tb["center_y"], interval = .1, button = "left", clicks = 3)
        __match_input(tb["text"])

def __btn_simulator(buttons):
    for btn in buttons:
        pg.moveTo(btn["x"], btn["y"], duration = .25)
        pg.click(button = "left", clicks = 1)
        break

    buttons.clear()

def __match(text):
    if "@" in text or text in EMAIL:
        return text_input["email"]
    if "your full" in text or text in FULL_NAME:
        return text_input["name"]
    if text in FIRST_NAME:
        return text_input["firstname"]
    if text in LAST_NAME:
        return text_input["lastname"]
    if "phone" in text or text in PHONE:
        return text_input["phone"]
    if text in EMAIL:
        return text_input["email"]
    if text in PHONE:
        return text_input["password"]
    if "site" in text or text in WEBSITE:
        return text_input["website"]
    return "defaultinput"

def __match_input(text):
    pg.typewrite(__match(text), interval = TEXT_INTERVAL)
    print(__match(text))


# ---------------------------------------------------------------------------------------------------------------
# Main functions
# ---------------------------------------------------------------------------------------------------------------
def get_options(argv):
    try:
        opts, args = options.getopt(argv,"evr",["error","valid", "fallback"])
    except options.GetoptError:
        sys.exit(1)
        
    simulate_error = False
    simulate_valid = False
    fallback = False
    
    for opt, arg in opts:
        if opt in ("-e", "--error"):
            simulate_error = True
        elif opt in ("-v", "--valid"):
            simulate_valid = True
        elif opt in ("-r", "--fallback"):
            fallback = True
    if simulate_error or simulate_valid or fallback:
        return (simulate_error, simulate_valid, fallback)
    return (False, True, False)

def simulate_user_input(error, valid, fallback):
    "Simulate inputs"
    # TODO: check for simulation option (error/valid/etc)
    boxes = __get_results()
    tests = __get_test_cases()
    print(tests)
    classified_boxes = __classify_boxes(boxes, tests, fallback)

    # simulate errors
    if error:
        for item in classified_boxes:
            for error in item["error"]:
                __simulate_error(item, error, classified_boxes)

    # simulate lower valids
    if valid:
        for item in classified_boxes:
            __input_text_at(item["valid"]["Item1"], item)

        # simulate upper valids
        for item in classified_boxes:
            __input_text_at(item["valid"]["Item2"], item)

    sys.exit(0)


# ---------------------------------------------------------------------------------------------------------------
# Run
# ---------------------------------------------------------------------------------------------------------------
if __name__ == "__main__":
    (error, valid, fallback) = get_options(sys.argv[1:])
    simulate_user_input(error, valid, fallback)